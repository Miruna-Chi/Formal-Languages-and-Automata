Chiricu Miruna
332CB

			Tema 2 - LFA
			

	Folosim conversia NFA->DFA prezentata la curs:

- Considerand ca toate comentariile din cod sunt suficiente pentru a intelege
fiecare functie si cum functioneaza ansamblul, aici voi descrie foarte pe larg
ideea de implementare, deci modul in care se face conversia: 

	~ state_matrix ~
	
	Deoarece starile din DFA pot corespunde mai multor stari din NFA
(pentru ca in NFA pe acelasi simbol, putem pleca pe mai multe drumuri +
tranzitiile pe epsilon), am decis sa creez o matrice a 
starilor in DFA:	
	- matricea este o lista compusa din liste sortate (pentru a nu
le repeta) de stari ale NFA-ului
	- fiecare lista reprezinta o stare a DFA-ului compusa din una sau
mai multe stari ale NFA-ului. Index-ul fiecarei liste va fi numele/numarul
starii din DFA
	Ex: [[0], [0, 1, 2], [0, 2], [1, 2]...] -> [0, 1, 2, 3...]
	
		
	~ find_next_state ~
			
	Incepand cu starea 0 (vom crea din ce in ce mai multe stari pe masura
ce se avanseaza in for), pentru fiecare simbol din alfabet, cautam toate 
starile urmatoare valide (deci dintr-o stare compusa, ne ducem pe toate starile
partiale), incluzand toate tranzitiile pe epsilon). Facem un BFS conditionat
pentru toate posibilele stari pornind din starea curenta. Astfel vom avea o
coada si un set de stari vizitate. Un element din coada va fi un tuplu care 
arata astfel:
	(stare_partiala_curenta, simbol_cautat, e_necesar_sa_mai_caut_simbolul?)
	Ex: (1, 'b', True)
	A treia componenta a tuplului imi indica daca mai e necesar sa caut
o tranzitie pe simbol in continuare (daca l-am gasit o data pe calea curenta,
nu am voie decat sa caut tranzitii pe epsilon in continuare). Daca nu am gasit
inca simbolul pe calea curenta, pot sa ma duc atat pe tranzitii pe epsilon,
cat si pe simbol.
	Se vor diferentia in visited tuplurile care au primele doua elemente
comune si pe al treilea diferit (daca ajung in aceeasi stare, o data cautand
simbolul, alta data nu, inseamna ca sunt cel putin doua cai pe care am ajuns
in acea stare, deci va fi util sa caut mai departe pentru ambele.
	Se considera valide (si le adaugam la setul de stari urmatoare pentru
simbolul curent) starile ce fac parte din tuplurile pentru care deja am gasit
simbolul pe calea curenta (a treia componenta este False).

	Dupa cum am explicat mai devreme, se va forma un set cu urmatoarele
stari partiale valide pentru fiecare stare compusa, formand o alta stare 
compusa (pe care o adaugam in matricea starilor daca nu exista deja).
	Ex: Suntem in starea 012 si avem simbolul 'b'
	Apelam functia find_next_state pentru 0, 1, 2 separat. Fiecare va
returna un set (vid sau nu) de stari urmatoare valide. Din cele 3 seturi
se va forma setul final care va face parte din matricea starilor.
	Din absenta tranzitiior in delta NFA-ului, s-ar putea ca si acest
set final sa fie vid. Atunci tranzitia va duce intr-un sink_state.

	~ sink_state ~
	
	Dupa ce parcurgem toate starile, daca stim ca exista macar o tranzitie
pe sink_state, adaugam aceasta stare la starile curente (va fi ultima din
matrice, deci starea cu numarul cel mai mare) si facem modificarile necesare
in delta.
	
	~ final_states ~
	
	Starile finale vor fi stari din matricea starilor care contin cel
putin o stare finala a NFA-ului.
	Ex:
	Matricea starilor: [[0], [1, 2], [0, 1], ...]
	Stari finale NFA: 0, 2
	Stari finale DFA: [0], [1, 2], deci starile 0, 1 (indecsii listelor
in matricea starilor corespund numelor starilor DFA-ului)
	
	

	
	
